
input relation Edge(snode: string, dnode: string, int: usize)
input relation Node(node: string)
output relation Shortest_path_cost(snode: string, dnode: string, int: usize, path: Vec<string>)

// Base case: Initialize distances
Shortest_path_cost(src, src, 0, vec_empty()) :-
    Node(src).

Shortest_path_cost(src, dest, dist, vec_empty()) :-
    Node(src),
    Node(dest),
    Edge(src, dest, _),
    src != dest,
    Edge(src, dest, dist).

// Recursive case: Compute shortest path
Shortest_path_cost(src, dest, distX + distDest, path) :-
    Node(src),
    Node(dest),
    src != dest,
    Edge(src, x, distX),
    Shortest_path_cost(x, dest, distDest, orig_path),
    var path = push_path(orig_path, x).

function push_path(orig_path: Vec<string>, node_name: string): Vec<string> {
    var res: Vec<string> = vec_empty();
    for (p in orig_path) {
        vec_push(res, p);
    };
    vec_push(res, node_name);
    res
}